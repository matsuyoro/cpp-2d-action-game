
#include <windows.h>
#include <ddraw.h>

#include "Extern.h"
#include "BltProc.h"
#include "SaveLoadProc.h"

#include "BackProc.h"
#include "GameCheckProc.h"

///////////// プロトタイプ宣言 ////////////////////////
void StageSetUp_0();	//ステージ０をはじめるための準備の関数のプロトタイプ宣言
void StageSetUp_1();	//ステージ１をはじめるための準備の関数のプロトタイプ宣言
void StageSetUp_2();	//ステージ２をはじめるための準備の関数のプロトタイプ宣言
void StageSetUp_3();	//ステージ３を始めるための準備の関数のプロトタイプ宣言
void StageSetUp_4();	//ステージ４を始めるための準備の関数のプロトタイプ宣言

//■　StageSelect　■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
void StageSelect(int *pGameNum)	//	機能：ステージセレクト画面の処理
//	●引数：ゲームの場面を扱う値
{
	HDC hdc;				//デバイスコンテキスト
	char str[256];			//文字列を扱う
	int i;					//カウンタ
	DDBLTFX ddbltfx;		//ぬりつぶしに必要な構造体
	static int ArwCnt;		//選択しているステージを指す矢印の移動に使う
	static int ArwAni;		//矢印のアニメーションカウンタ
	static int ClrNum;		//パレット操作で使う色を変化させるのに使用

	void (*pStage[5])();	//戻値なし、引数int型ポインタの関数のアドレスの、関数のポインタ配列の宣言
	pStage[0] = StageSetUp_0;	//pStage[0]に定義関数StageSetUp_0の先頭アドレスを代入
	pStage[1] = StageSetUp_1;
	pStage[2] = StageSetUp_2;
	pStage[3] = StageSetUp_3;
	pStage[4] = StageSetUp_4;

	//ぬりつぶし（黒）
	ddbltfx.dwSize = sizeof(ddbltfx);		//構造体のサイズを指定する
	ddbltfx.dwFillColor = 0;				//ぬりつぶす色を指定
	lpDDSBackBuffer -> Blt(NULL,NULL,NULL,	//指定の色でぬりつぶし
		DDBLT_COLORFILL | DDBLT_WAIT,
		&ddbltfx);

	//パレット変化
	ClrNum++;
	if(ClrNum > 127)	ClrNum = 0;
	//矢印の移動
	ArwCnt++;
	if(ArwCnt > 50)		ArwCnt = 50;
	//矢印のアニメーション
	ArwAni++;
	if(ArwAni > 3)		ArwAni = 0;

	if(CmdNum[0] == 2 && CmdCnt[0] == 1)	
	{
		StageNum --;	//上を押したら
		ArwCnt = 0;		//矢印を元の座標に戻す
	}
	if(CmdNum[0] == 8 && CmdCnt[0] == 1)
	{
		StageNum ++;	//下を押したら
		ArwCnt = 0;		//矢印を元の座標に戻す
	}

	if(StageNum < 0) StageNum = 0;	//０より小さくならないようにする
	(StageNum %= 5);					//限界を持たせる


	if(!(Btn2 & (1<<1)) && (Btn1 & (1<<1)))	//Bボタンを前回（離）で現在（押）なら 
	{
		
		for(i = 0;i < ENE_MAX;i++)	//敵キャラを全部存在させなくする
		{
			En[i].Son = FALSE;			//存在をFALSEに
		}
		for(i = 0;i < SHOT_MAX;i++)	//弾を全部存在させなくする
		{
			Shot[i].Son = FALSE;		//存在をFALSEに
		}

		//▼適出現位置データのメモリ解放
		if(pEneOn == NULL)	//解放しようとしている変数のメモリが確保されていなかったら
			MessageBox(NULL,"ポインタ変数にはメモリが確保されていません(pEneOn)","エラー",MB_OK);
		pEneOn = (ENE_ONPOS*)GlobalFree(pEneOn);	//メモリ解放
		if(pEneOn != NULL)	//GlobalFreeの戻値がNULLじゃなかったらエラー通知
			MessageBox(NULL,"メモリ解放失敗","エラー(pEneOn)",MB_OK);	

		//▼マップデータのメモリ解放
		if(pMap == NULL)	//解放しようとしている変数のメモリが確保されていなかったら
			MessageBox(NULL,"ポインタ変数にはメモリが確保されていません(pMap)","エラー",MB_OK);
		pMap = (int *)GlobalFree(pMap);	//メモリ解放
		if(pMap != NULL)	//GlobalFreeの戻り値がNULLじゃなかったらエラー通知
			MessageBox(NULL,"メモリ解放失敗","エラー(pMap)",MB_OK);					//エラーをメッセージボックスで表示

		//▼ステージをはじめるための準備を行う
		pStage[StageNum]();	//関数のポインタ配列の要素番号（SlctNum）に対応した関数を実行

		*pGameNum = 1;	//間接参照でGameNumを１（ゲーム本編）にする。
	}


	lpDDPal->GetEntries(0,0,255,SubPal);
	SubPal[127].peRed  = 255;
	SubPal[127].peGreen = ClrNum<<1;
	SubPal[127].peBlue = 255;
	lpDDPal->SetEntries(0,0,255,SubPal);


	BGBlt();					//●背景表示

	//画像を描画
	MyBltFast(65,100,	
			lpDDSOff_StageSelect,
			0,0,
			518,264);


	for(i = 0;i < 5;i++)
	{
		if(i == StageNum)
			SetTextColor(hdc,RGB(0,255,0));
		else
			SetTextColor(hdc,RGB(160,160,160));		//文字色の指定

		MyBltFast(250+(i*200)-(StageNum*200),180,
					lpDDSOff_Text,
					352,448,
					424,480);
		MyBltFast(250+(i*200)-(StageNum*200)+80,180,
					lpDDSOff_Text,
					352+(i*16),416,
					352+(i*16)+16,448);
	}
	MyBltFast(	290,70+ArwCnt,
				lpDDSOff_Text,
				512+(ArwAni*16),416,
				512+(ArwAni*16)+16,448);
	MyBltFast(	290,280-ArwCnt,
				lpDDSOff_Text,
				512+(ArwAni*16),448,
				512+(ArwAni*16)+16,480);



	//描画を行うサーフェースのデバイスコンテキストを取得
	lpDDSBackBuffer->GetDC(&hdc);

	//文字表示
	SetBkColor(hdc,RGB(255,0,0));			//文字のバックカラーの指定
	SetBkMode(hdc,TRANSPARENT);				//文字を透明にする
/*
	for(i = 0;i < 5;i++)
	{
		if(i == StageNum)
			SetTextColor(hdc,RGB(0,255,0));
		else
			SetTextColor(hdc,RGB(160,160,160));		//文字色の指定

		wsprintf(str,"Stage %d",i);
		TextOut(hdc,250+(i*200)-(StageNum*200),140,str,lstrlen(str));
		
	}
*/
	//デバイスコンテキストの解放
	lpDDSBackBuffer->ReleaseDC(hdc);

}//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

//===================================================================================================
void StageSetUp_0()	//機能：ステージ０をはじめるための準備の関数
{
	int i;					//カウンタ
	int Tip_00[TIP_MAX] =	//森のステージのチップ通過フラグを扱うデータ
	//	0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0	//森のステージ
	{	0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,	//1
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,
		1,1,1,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,
		1,1,1,1,1,2,1,1,1,1,2,1,1,1,2,1,2,2,2,2,	//5
		1,1,1,1,1,1,2,2,2,1,2,2,2,1,2,1,2,2,2,2,
		1,1,1,1,1,1,2,2,2,2,2,2,2,1,2,2,2,1,1,1,
		1,1,1,1,1,1,1,2,2,1,2,2,2,2,2,2,2,1,1,1,
		1,1,1,1,1,1,1,2,2,2,2,2,2,2,1,2,1,1,1,1,
		1,1,1,1,1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,1,	//10
		1,1,1,1,1,1,1,1,1,1,3,2,3,2,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,3,2,3,2,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,	};//15

	//ゲームで使用するチップ通過フラグTipに廃墟ステージ用のTip_01を代入
	for(i = 0;i < TIP_MAX;i++)
		Tip[i] = Tip_00[i];


	GameLoad("MAP\\MAP0_320-40_tipbmp8.map");
	EneOnPosLoad("ENEON0_30.enp");				//エネミーの出現位置データをロード

	WMoveX = 0;
	WMoveY = 0;
	Plr.x = 200;
	Plr.y = 120;

}
//===================================================================================================
void StageSetUp_1()	//機能：ステージ１のはじめるための準備の関数
{
	int i;
	int BGLine;				//背景オブジェの設置する列を扱う

	int Tip_01[TIP_MAX] =	//廃墟のステージのチップ通過フラグを扱うデータを初期化 
	//マップチップの通過フラグ
	//	0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0	//廃墟のステージ
	{	0,1,1,1,1,1,2,2,2,2,2,2,2,1,1,1,1,1,1,1,	//1
		1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,	//5
		1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,1,
		1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,1,
		1,1,1,1,1,1,1,1,1,1,2,2,2,1,2,2,2,2,2,1,
		3,1,2,2,3,2,1,2,2,1,2,1,2,1,2,2,2,2,2,1,
		2,1,1,1,3,2,1,1,1,1,1,1,1,2,1,2,2,1,1,1,	//10
		1,1,1,1,3,2,1,1,1,1,1,1,1,2,2,2,2,1,1,1,
		1,1,1,1,3,2,1,1,1,1,1,2,2,2,2,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,2,2,1,1,1,1,1,1,1,	};//15

	//ゲームで使用するチップ通過フラグTipに廃墟ステージ用のTip_01を代入
	for(i = 0;i < TIP_MAX;i++)
		Tip[i] = Tip_01[i];

	GameLoad("MAP\\MAP_640-40_tip7.map");	//マップデータロード
	EneOnPosLoad("ENE_50_tip7.enp");			//エネミー出現位置ロード

	//背景のオブジェクトの初期設置(廃墟のステージ用
	for(i = 0;i < 30;i++)
	{
		BGLine = i/5;	//６列分乱数を作る(上の列から配置していく
		BGLine %= 7;
		if(i < 28)	//〜２７までは普通に配置
			BgObjOn(BgObj,rand()%640,240+(BGLine*40)+39,rand()%23,BGLine);	//背景オブジェを設置
		else if(i == 28)	//２８個目はType23を配置
			BgObjOn(BgObj,rand()%640,240+(BGLine*40)+39,23,BGLine);
		else if(i == 29)	//２９個目はType２４を配置
			BgObjOn(BgObj,rand()%640,240+(BGLine*40)+39,24,BGLine);

	}
	
	lpDDPal->GetEntries(0,0,255,SubPal);

	for(i = 0 ;i < 255;i++)
	{
		if(SubPal[i].peGreen > 50)
			SubPal[i].peGreen -= 50;	//緑の要素をへらす
		if(SubPal[i].peBlue > 50)
			SubPal[i].peBlue -= 50;		//青の要素を減らす
	}
	lpDDPal->SetEntries(0,0,256,SubPal);

	WMoveX = 500<<5;
	WMoveY = 0;
	Plr.x = 200;
	Plr.y = 120;
}
//===================================================================================================
void StageSetUp_2()	//機能：ステージ2のはじめるための準備の関数
{
	int i;
	int BGLine;				//背景オブジェの設置する列を扱う
	int Tip_01[TIP_MAX] =	//砂漠基地のステージのチップ通過フラグを扱うデータを初期化 
	//マップチップの通過フラグ
	//	0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0	//廃墟のステージ
	{	0,1,1,1,1,1,2,2,2,2,2,2,2,1,1,1,1,1,1,1,	//1
		1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,	//5
		1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,1,
		1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,1,
		1,1,1,1,1,1,1,1,1,1,2,2,2,1,2,2,2,2,2,1,
		3,1,2,2,3,2,1,2,2,1,2,1,2,1,2,2,2,2,2,1,
		2,1,1,1,3,2,1,1,1,1,1,1,1,2,1,2,2,1,1,1,	//10
		1,1,1,1,3,2,1,1,1,1,1,1,1,2,2,2,2,1,1,1,
		1,1,1,1,3,2,1,1,1,1,1,2,2,2,2,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,2,2,1,1,1,1,1,1,1,	};//15

	//ゲームで使用するチップ通過フラグTipに廃墟ステージ用のTip_01を代入
	for(i = 0;i < TIP_MAX;i++)
		Tip[i] = Tip_01[i];

	GameLoad("MAP\\MAP_480-48_tip7.map");	//マップデータロード
	EneOnPosLoad("ENE_50_tip7.enp");			//エネミー出現位置ロード

	//背景のオブジェクトの初期設置(廃墟のステージ用
	for(i = 0;i < 30;i++)
	{
		BGLine = i/5;	//６列分乱数を作る(上の列から配置していく
		BGLine %= 7;
		BgObjOn(BgObj,rand()%640,240+(BGLine*40)+39,rand()%25,BGLine);	//背景オブジェを設置
	}

	lpDDPal->SetEntries(0,0,256,MainPal);	//とりあえずパレットを元に戻してから

	//ステージを暗くしてから始める
	lpDDPal->GetEntries(0,0,255,SubPal);
	//取得したパレットデータの、赤、緑、青の要素をクリメントし、元の色に近づけいく
	for(i = 0;i < 255;i++)
	{
		SubPal[i].peRed = 0;	//赤を０	
		SubPal[i].peGreen = 0;	//緑を０
	}
	lpDDPal->SetEntries(0,0,256,SubPal);

	WMoveX = 0;
	WMoveY = 0;
	Plr.x = 200;
	Plr.y = 120;
}
//===================================================================================================
void StageSetUp_3()	//機能：ステージ０をはじめるための準備の関数
{
	int i;					//カウンタ
	int Tip_00[TIP_MAX] =	//嵐のステージのチップ通過フラグを扱うデータ
	//	0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0	//嵐のステージ
	{	0,1,1,1,1,1,1,1,1,1,1,3,2,1,1,1,1,1,1,1,	//1
		1,1,1,1,1,1,1,1,1,1,1,3,2,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,
		1,1,1,2,2,2,2,2,2,2,2,1,3,2,2,2,2,2,2,2,
		1,1,1,1,1,2,1,1,1,1,2,1,1,1,2,1,2,2,2,2,	//5
		1,1,1,1,1,1,2,2,2,1,2,2,2,1,2,1,2,2,2,2,
		1,1,1,1,1,1,2,2,2,2,2,2,2,1,2,2,2,1,1,1,
		1,1,1,1,1,1,1,2,2,1,2,2,2,2,2,2,2,1,1,1,
		1,1,1,1,1,1,1,2,2,2,2,2,2,2,1,2,1,1,1,1,
		1,1,1,1,1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,1,	//10
		1,1,1,1,1,1,1,1,1,1,3,2,3,2,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,3,2,3,2,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,	};//15

	//ゲームで使用するチップ通過フラグTipに嵐ステージ用のTip_01を代入
	for(i = 0;i < TIP_MAX;i++)
		Tip[i] = Tip_00[i];


	GameLoad("MAP\\MAP_streit_640-40_tip8.map");
	EneOnPosLoad("ENE_50_tip7.enp");				//エネミーの出現位置データをロード

	WMoveX = 0;
	WMoveY = 0;
	Plr.x = 200;
	Plr.y = 120;

}
//===================================================================================================
void StageSetUp_4()	//機能：ステージ０をはじめるための準備の関数
{
	int i;					//カウンタ
	int Tip_02[TIP_MAX] =	//メカのステージのチップ通過フラグを扱うデータ
	//	0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0	//メカのステージ
	{	0,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,	//1
		2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,
		2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,2,2,2,2,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,2,2,2,2,1,1,1,1,1,1,1,1,1,	//5
		1,1,1,1,1,1,1,2,2,2,2,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,2,2,2,2,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,	//10
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,	};//15

	//ゲームで使用するチップ通過フラグTipに嵐ステージ用のTip_01を代入
	for(i = 0;i < TIP_MAX;i++)
		Tip[i] = Tip_02[i];


	GameLoad("MAP\\MAP_meka.map");
	EneOnPosLoad("ENE_50_tip7.enp");				//エネミーの出現位置データをロード

	WMoveX = 0;
	WMoveY = 0;
	Plr.x = 200;
	Plr.y = 120;

}